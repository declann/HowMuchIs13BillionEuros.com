const vt=1024;let At=0;class P{constructor(t,e){this.from=t,this.to=e}}class v{constructor(t={}){this.id=At++,this.perNode=!!t.perNode,this.deserialize=t.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(t){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return typeof t!="function"&&(t=O.match(t)),e=>{let r=t(e);return r===void 0?null:[this,r]}}}v.closedBy=new v({deserialize:o=>o.split(" ")}),v.openedBy=new v({deserialize:o=>o.split(" ")}),v.group=new v({deserialize:o=>o.split(" ")}),v.isolate=new v({deserialize:o=>{if(o&&o!="rtl"&&o!="ltr"&&o!="auto")throw new RangeError("Invalid value for isolate: "+o);return o||"auto"}}),v.contextHash=new v({perNode:!0}),v.lookAhead=new v({perNode:!0}),v.mounted=new v({perNode:!0});class q{constructor(t,e,r){this.tree=t,this.overlay=e,this.parser=r}static get(t){return t&&t.props&&t.props[v.mounted.id]}}const kt=Object.create(null);class O{constructor(t,e,r,n=0){this.name=t,this.props=e,this.id=r,this.flags=n}static define(t){let e=t.props&&t.props.length?Object.create(null):kt,r=(t.top?1:0)|(t.skipped?2:0)|(t.error?4:0)|(t.name==null?8:0),n=new O(t.name||"",e,t.id,r);if(t.props){for(let i of t.props)if(Array.isArray(i)||(i=i(n)),i){if(i[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");e[i[0].id]=i[1]}}return n}prop(t){return this.props[t.id]}get isTop(){return(this.flags&1)>0}get isSkipped(){return(this.flags&2)>0}get isError(){return(this.flags&4)>0}get isAnonymous(){return(this.flags&8)>0}is(t){if(typeof t=="string"){if(this.name==t)return!0;let e=this.prop(v.group);return e?e.indexOf(t)>-1:!1}return this.id==t}static match(t){let e=Object.create(null);for(let r in t)for(let n of r.split(" "))e[n]=t[r];return r=>{for(let n=r.prop(v.group),i=-1;i<(n?n.length:0);i++){let s=e[i<0?r.name:n[i]];if(s)return s}}}}O.none=new O("",Object.create(null),0,8);class st{constructor(t){this.types=t;for(let e=0;e<t.length;e++)if(t[e].id!=e)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...t){let e=[];for(let r of this.types){let n=null;for(let i of t){let s=i(r);s&&(n||(n=Object.assign({},r.props)),n[s[0].id]=s[1])}e.push(n?new O(r.name,n,r.id,r.flags):r)}return new st(e)}}const K=new WeakMap,lt=new WeakMap;var k;(function(o){o[o.ExcludeBuffers=1]="ExcludeBuffers",o[o.IncludeAnonymous=2]="IncludeAnonymous",o[o.IgnoreMounts=4]="IgnoreMounts",o[o.IgnoreOverlays=8]="IgnoreOverlays"})(k||(k={}));class M{constructor(t,e,r,n,i){if(this.type=t,this.children=e,this.positions=r,this.length=n,this.props=null,i&&i.length){this.props=Object.create(null);for(let[s,h]of i)this.props[typeof s=="number"?s:s.id]=h}}toString(){let t=q.get(this);if(t&&!t.overlay)return t.tree.toString();let e="";for(let r of this.children){let n=r.toString();n&&(e&&(e+=","),e+=n)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(e.length?"("+e+")":""):e}cursor(t=0){return new Y(this.topNode,t)}cursorAt(t,e=0,r=0){let n=K.get(this)||this.topNode,i=new Y(n);return i.moveTo(t,e),K.set(this,i._tree),i}get topNode(){return new B(this,0,0,null)}resolve(t,e=0){let r=X(K.get(this)||this.topNode,t,e,!1);return K.set(this,r),r}resolveInner(t,e=0){let r=X(lt.get(this)||this.topNode,t,e,!0);return lt.set(this,r),r}resolveStack(t,e=0){return _t(this,t,e)}iterate(t){let{enter:e,leave:r,from:n=0,to:i=this.length}=t,s=t.mode||0,h=(s&k.IncludeAnonymous)>0;for(let f=this.cursor(s|k.IncludeAnonymous);;){let a=!1;if(f.from<=i&&f.to>=n&&(!h&&f.type.isAnonymous||e(f)!==!1)){if(f.firstChild())continue;a=!0}for(;a&&r&&(h||!f.type.isAnonymous)&&r(f),!f.nextSibling();){if(!f.parent())return;a=!0}}}prop(t){return t.perNode?this.props?this.props[t.id]:void 0:this.type.prop(t)}get propValues(){let t=[];if(this.props)for(let e in this.props)t.push([+e,this.props[e]]);return t}balance(t={}){return this.children.length<=8?this:nt(O.none,this.children,this.positions,0,this.children.length,0,this.length,(e,r,n)=>new M(this.type,e,r,n,this.propValues),t.makeTree||((e,r,n)=>new M(O.none,e,r,n)))}static build(t){return It(t)}}M.empty=new M(O.none,[],[],0);class ot{constructor(t,e){this.buffer=t,this.index=e}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new ot(this.buffer,this.index)}}class U{constructor(t,e,r){this.buffer=t,this.length=e,this.set=r}get type(){return O.none}toString(){let t=[];for(let e=0;e<this.buffer.length;)t.push(this.childString(e)),e=this.buffer[e+3];return t.join(",")}childString(t){let e=this.buffer[t],r=this.buffer[t+3],n=this.set.types[e],i=n.name;if(/\W/.test(i)&&!n.isError&&(i=JSON.stringify(i)),t+=4,r==t)return i;let s=[];for(;t<r;)s.push(this.childString(t)),t=this.buffer[t+3];return i+"("+s.join(",")+")"}findChild(t,e,r,n,i){let{buffer:s}=this,h=-1;for(let f=t;f!=e&&!(ut(i,n,s[f+1],s[f+2])&&(h=f,r>0));f=s[f+3]);return h}slice(t,e,r){let n=this.buffer,i=new Uint16Array(e-t),s=0;for(let h=t,f=0;h<e;){i[f++]=n[h++],i[f++]=n[h++]-r;let a=i[f++]=n[h++]-r;i[f++]=n[h++]-t,s=Math.max(s,a)}return new U(i,s,this.set)}}function ut(o,t,e,r){switch(o){case-2:return e<t;case-1:return r>=t&&e<t;case 0:return e<t&&r>t;case 1:return e<=t&&r>t;case 2:return r>t;case 4:return!0}}function X(o,t,e,r){for(var n;o.from==o.to||(e<1?o.from>=t:o.from>t)||(e>-1?o.to<=t:o.to<t);){let s=!r&&o instanceof B&&o.index<0?null:o.parent;if(!s)return o;o=s}let i=r?0:k.IgnoreOverlays;if(r)for(let s=o,h=s.parent;h;s=h,h=s.parent)s instanceof B&&s.index<0&&((n=h.enter(t,e,i))===null||n===void 0?void 0:n.from)!=s.from&&(o=h);for(;;){let s=o.enter(t,e,i);if(!s)return o;o=s}}class at{cursor(t=0){return new Y(this,t)}getChild(t,e=null,r=null){let n=pt(this,t,e,r);return n.length?n[0]:null}getChildren(t,e=null,r=null){return pt(this,t,e,r)}resolve(t,e=0){return X(this,t,e,!1)}resolveInner(t,e=0){return X(this,t,e,!0)}matchContext(t){return et(this,t)}enterUnfinishedNodesBefore(t){let e=this.childBefore(t),r=this;for(;e;){let n=e.lastChild;if(!n||n.to!=e.to)break;n.type.isError&&n.from==n.to?(r=e,e=n.prevSibling):e=n}return r}get node(){return this}get next(){return this.parent}}class B extends at{constructor(t,e,r,n){super(),this._tree=t,this.from=e,this.index=r,this._parent=n}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(t,e,r,n,i=0){for(let s=this;;){for(let{children:h,positions:f}=s._tree,a=e>0?h.length:-1;t!=a;t+=e){let l=h[t],d=f[t]+s.from;if(ut(n,r,d,d+l.length)){if(l instanceof U){if(i&k.ExcludeBuffers)continue;let p=l.findChild(0,l.buffer.length,e,r-d,n);if(p>-1)return new R(new St(s,l,t,d),null,p)}else if(i&k.IncludeAnonymous||!l.type.isAnonymous||rt(l)){let p;if(!(i&k.IgnoreMounts)&&(p=q.get(l))&&!p.overlay)return new B(p.tree,d,t,s);let x=new B(l,d,t,s);return i&k.IncludeAnonymous||!x.type.isAnonymous?x:x.nextChild(e<0?l.children.length-1:0,e,r,n)}}}if(i&k.IncludeAnonymous||!s.type.isAnonymous||(s.index>=0?t=s.index+e:t=e<0?-1:s._parent._tree.children.length,s=s._parent,!s))return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(t){return this.nextChild(0,1,t,2)}childBefore(t){return this.nextChild(this._tree.children.length-1,-1,t,-2)}enter(t,e,r=0){let n;if(!(r&k.IgnoreOverlays)&&(n=q.get(this._tree))&&n.overlay){let i=t-this.from;for(let{from:s,to:h}of n.overlay)if((e>0?s<=i:s<i)&&(e<0?h>=i:h>i))return new B(n.tree,n.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,t,e,r)}nextSignificantParent(){let t=this;for(;t.type.isAnonymous&&t._parent;)t=t._parent;return t}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}get tree(){return this._tree}toTree(){return this._tree}toString(){return this._tree.toString()}}function pt(o,t,e,r){let n=o.cursor(),i=[];if(!n.firstChild())return i;if(e!=null){for(let s=!1;!s;)if(s=n.type.is(e),!n.nextSibling())return i}for(;;){if(r!=null&&n.type.is(r))return i;if(n.type.is(t)&&i.push(n.node),!n.nextSibling())return r==null?i:[]}}function et(o,t,e=t.length-1){for(let r=o.parent;e>=0;r=r.parent){if(!r)return!1;if(!r.type.isAnonymous){if(t[e]&&t[e]!=r.name)return!1;e--}}return!0}class St{constructor(t,e,r,n){this.parent=t,this.buffer=e,this.index=r,this.start=n}}class R extends at{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(t,e,r){super(),this.context=t,this._parent=e,this.index=r,this.type=t.buffer.set.types[t.buffer.buffer[r]]}child(t,e,r){let{buffer:n}=this.context,i=n.findChild(this.index+4,n.buffer[this.index+3],t,e-this.context.start,r);return i<0?null:new R(this.context,this,i)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(t){return this.child(1,t,2)}childBefore(t){return this.child(-1,t,-2)}enter(t,e,r=0){if(r&k.ExcludeBuffers)return null;let{buffer:n}=this.context,i=n.findChild(this.index+4,n.buffer[this.index+3],e>0?1:-1,t-this.context.start,e);return i<0?null:new R(this.context,this,i)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(t){return this._parent?null:this.context.parent.nextChild(this.context.index+t,t,0,4)}get nextSibling(){let{buffer:t}=this.context,e=t.buffer[this.index+3];return e<(this._parent?t.buffer[this._parent.index+3]:t.buffer.length)?new R(this.context,this._parent,e):this.externalSibling(1)}get prevSibling(){let{buffer:t}=this.context,e=this._parent?this._parent.index+4:0;return this.index==e?this.externalSibling(-1):new R(this.context,this._parent,t.findChild(e,this.index,-1,0,4))}get tree(){return null}toTree(){let t=[],e=[],{buffer:r}=this.context,n=this.index+4,i=r.buffer[this.index+3];if(i>n){let s=r.buffer[this.index+1];t.push(r.slice(n,i,s)),e.push(0)}return new M(this.type,t,e,this.to-this.from)}toString(){return this.context.buffer.childString(this.index)}}function dt(o){if(!o.length)return null;let t=0,e=o[0];for(let i=1;i<o.length;i++){let s=o[i];(s.from>e.from||s.to<e.to)&&(e=s,t=i)}let r=e instanceof B&&e.index<0?null:e.parent,n=o.slice();return r?n[t]=r:n.splice(t,1),new Ct(n,e)}class Ct{constructor(t,e){this.heads=t,this.node=e}get next(){return dt(this.heads)}}function _t(o,t,e){let r=o.resolveInner(t,e),n=null;for(let i=r instanceof B?r:r.context.parent;i;i=i.parent)if(i.index<0){let s=i.parent;(n||(n=[r])).push(s.resolve(t,e)),i=s}else{let s=q.get(i.tree);if(s&&s.overlay&&s.overlay[0].from<=t&&s.overlay[s.overlay.length-1].to>=t){let h=new B(s.tree,s.overlay[0].from+i.from,-1,i);(n||(n=[r])).push(X(h,t,e,!1))}}return n?dt(n):r}class Y{get name(){return this.type.name}constructor(t,e=0){if(this.mode=e,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,t instanceof B)this.yieldNode(t);else{this._tree=t.context.parent,this.buffer=t.context;for(let r=t._parent;r;r=r._parent)this.stack.unshift(r.index);this.bufferNode=t,this.yieldBuf(t.index)}}yieldNode(t){return t?(this._tree=t,this.type=t.type,this.from=t.from,this.to=t.to,!0):!1}yieldBuf(t,e){this.index=t;let{start:r,buffer:n}=this.buffer;return this.type=e||n.set.types[n.buffer[t]],this.from=r+n.buffer[t+1],this.to=r+n.buffer[t+2],!0}yield(t){return t?t instanceof B?(this.buffer=null,this.yieldNode(t)):(this.buffer=t.context,this.yieldBuf(t.index,t.type)):!1}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(t,e,r){if(!this.buffer)return this.yield(this._tree.nextChild(t<0?this._tree._tree.children.length-1:0,t,e,r,this.mode));let{buffer:n}=this.buffer,i=n.findChild(this.index+4,n.buffer[this.index+3],t,e-this.buffer.start,r);return i<0?!1:(this.stack.push(this.index),this.yieldBuf(i))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(t){return this.enterChild(1,t,2)}childBefore(t){return this.enterChild(-1,t,-2)}enter(t,e,r=this.mode){return this.buffer?r&k.ExcludeBuffers?!1:this.enterChild(1,t,e):this.yield(this._tree.enter(t,e,r))}parent(){if(!this.buffer)return this.yieldNode(this.mode&k.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let t=this.mode&k.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(t)}sibling(t){if(!this.buffer)return this._tree._parent?this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+t,t,0,4,this.mode)):!1;let{buffer:e}=this.buffer,r=this.stack.length-1;if(t<0){let n=r<0?0:this.stack[r]+4;if(this.index!=n)return this.yieldBuf(e.findChild(n,this.index,-1,0,4))}else{let n=e.buffer[this.index+3];if(n<(r<0?e.buffer.length:e.buffer[this.stack[r]+3]))return this.yieldBuf(n)}return r<0?this.yield(this.buffer.parent.nextChild(this.buffer.index+t,t,0,4,this.mode)):!1}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(t){let e,r,{buffer:n}=this;if(n){if(t>0){if(this.index<n.buffer.buffer.length)return!1}else for(let i=0;i<this.index;i++)if(n.buffer.buffer[i+3]<this.index)return!1;({index:e,parent:r}=n)}else({index:e,_parent:r}=this._tree);for(;r;{index:e,_parent:r}=r)if(e>-1)for(let i=e+t,s=t<0?-1:r._tree.children.length;i!=s;i+=t){let h=r._tree.children[i];if(this.mode&k.IncludeAnonymous||h instanceof U||!h.type.isAnonymous||rt(h))return!1}return!0}move(t,e){if(e&&this.enterChild(t,0,4))return!0;for(;;){if(this.sibling(t))return!0;if(this.atLastNode(t)||!this.parent())return!1}}next(t=!0){return this.move(1,t)}prev(t=!0){return this.move(-1,t)}moveTo(t,e=0){for(;(this.from==this.to||(e<1?this.from>=t:this.from>t)||(e>-1?this.to<=t:this.to<t))&&this.parent(););for(;this.enterChild(1,t,e););return this}get node(){if(!this.buffer)return this._tree;let t=this.bufferNode,e=null,r=0;if(t&&t.context==this.buffer)t:for(let n=this.index,i=this.stack.length;i>=0;){for(let s=t;s;s=s._parent)if(s.index==n){if(n==this.index)return s;e=s,r=i+1;break t}n=this.stack[--i]}for(let n=r;n<this.stack.length;n++)e=new R(this.buffer,e,this.stack[n]);return this.bufferNode=new R(this.buffer,e,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(t,e){for(let r=0;;){let n=!1;if(this.type.isAnonymous||t(this)!==!1){if(this.firstChild()){r++;continue}this.type.isAnonymous||(n=!0)}for(;n&&e&&e(this),n=this.type.isAnonymous,!this.nextSibling();){if(!r)return;this.parent(),r--,n=!0}}}matchContext(t){if(!this.buffer)return et(this.node,t);let{buffer:e}=this.buffer,{types:r}=e.set;for(let n=t.length-1,i=this.stack.length-1;n>=0;i--){if(i<0)return et(this.node,t,n);let s=r[e.buffer[this.stack[i]]];if(!s.isAnonymous){if(t[n]&&t[n]!=s.name)return!1;n--}}return!0}}function rt(o){return o.children.some(t=>t instanceof U||!t.type.isAnonymous||rt(t))}function It(o){var t;let{buffer:e,nodeSet:r,maxBufferLength:n=1024,reused:i=[],minRepeatType:s=r.types.length}=o,h=Array.isArray(e)?new ot(e,e.length):e,f=r.types,a=0,l=0;function d(y,w,u,S,b,m){let{id:c,start:g,end:C,size:A}=h,T=l;for(;A<0;)if(h.next(),A==-1){let D=i[c];u.push(D),S.push(g-y);return}else if(A==-3){a=c;return}else if(A==-4){l=c;return}else throw new RangeError(`Unrecognized record size: ${A}`);let H=f[c],G,J,ht=g-y;if(C-g<=n&&(J=F(h.pos-w,b))){let D=new Uint16Array(J.size-J.skip),E=h.pos-J.size,W=D.length;for(;h.pos>E;)W=j(J.start,D,W);G=new U(D,C-J.start,r),ht=J.start-y}else{let D=h.pos-A;h.next();let E=[],W=[],V=c>=s?c:-1,$=0,Z=C;for(;h.pos>D;)V>=0&&h.id==V&&h.size>=0?(h.end<=Z-n&&(_(E,W,g,$,h.end,Z,V,T),$=E.length,Z=h.end),h.next()):m>2500?p(g,D,E,W):d(g,D,E,W,V,m+1);if(V>=0&&$>0&&$<E.length&&_(E,W,g,$,g,Z,V,T),E.reverse(),W.reverse(),V>-1&&$>0){let ft=x(H);G=nt(H,E,W,0,E.length,0,C-g,ft,ft)}else G=N(H,E,W,C-g,T-C)}u.push(G),S.push(ht)}function p(y,w,u,S){let b=[],m=0,c=-1;for(;h.pos>w;){let{id:g,start:C,end:A,size:T}=h;if(T>4)h.next();else{if(c>-1&&C<c)break;c<0&&(c=A-n),b.push(g,C,A),m++,h.next()}}if(m){let g=new Uint16Array(m*4),C=b[b.length-2];for(let A=b.length-3,T=0;A>=0;A-=3)g[T++]=b[A],g[T++]=b[A+1]-C,g[T++]=b[A+2]-C,g[T++]=T;u.push(new U(g,b[2]-C,r)),S.push(C-y)}}function x(y){return(w,u,S)=>{let b=0,m=w.length-1,c,g;if(m>=0&&(c=w[m])instanceof M){if(!m&&c.type==y&&c.length==S)return c;(g=c.prop(v.lookAhead))&&(b=u[m]+c.length+g)}return N(y,w,u,S,b)}}function _(y,w,u,S,b,m,c,g){let C=[],A=[];for(;y.length>S;)C.push(y.pop()),A.push(w.pop()+u-b);y.push(N(r.types[c],C,A,m-b,g-m)),w.push(b-u)}function N(y,w,u,S,b=0,m){if(a){let c=[v.contextHash,a];m=m?[c].concat(m):[c]}if(b>25){let c=[v.lookAhead,b];m=m?[c].concat(m):[c]}return new M(y,w,u,S,m)}function F(y,w){let u=h.fork(),S=0,b=0,m=0,c=u.end-n,g={size:0,start:0,skip:0};t:for(let C=u.pos-y;u.pos>C;){let A=u.size;if(u.id==w&&A>=0){g.size=S,g.start=b,g.skip=m,m+=4,S+=4,u.next();continue}let T=u.pos-A;if(A<0||T<C||u.start<c)break;let H=u.id>=s?4:0,G=u.start;for(u.next();u.pos>T;){if(u.size<0)if(u.size==-3)H+=4;else break t;else u.id>=s&&(H+=4);u.next()}b=G,S+=A,m+=H}return(w<0||S==y)&&(g.size=S,g.start=b,g.skip=m),g.size>4?g:void 0}function j(y,w,u){let{id:S,start:b,end:m,size:c}=h;if(h.next(),c>=0&&S<s){let g=u;if(c>4){let C=h.pos-(c-4);for(;h.pos>C;)u=j(y,w,u)}w[--u]=g,w[--u]=m-y,w[--u]=b-y,w[--u]=S}else c==-3?a=S:c==-4&&(l=S);return u}let z=[],I=[];for(;h.pos>0;)d(o.start||0,o.bufferStart||0,z,I,-1,0);let L=(t=o.length)!==null&&t!==void 0?t:z.length?I[0]+z[0].length:0;return new M(f[o.topID],z.reverse(),I.reverse(),L)}const ct=new WeakMap;function tt(o,t){if(!o.isAnonymous||t instanceof U||t.type!=o)return 1;let e=ct.get(t);if(e==null){e=1;for(let r of t.children){if(r.type!=o||!(r instanceof M)){e=1;break}e+=tt(o,r)}ct.set(t,e)}return e}function nt(o,t,e,r,n,i,s,h,f){let a=0;for(let _=r;_<n;_++)a+=tt(o,t[_]);let l=Math.ceil(a*1.5/8),d=[],p=[];function x(_,N,F,j,z){for(let I=F;I<j;){let L=I,y=N[I],w=tt(o,_[I]);for(I++;I<j;I++){let u=tt(o,_[I]);if(w+u>=l)break;w+=u}if(I==L+1){if(w>l){let u=_[L];x(u.children,u.positions,0,u.children.length,N[L]+z);continue}d.push(_[L])}else{let u=N[I-1]+_[I-1].length-y;d.push(nt(o,_,N,L,I,y,u,null,f))}p.push(y+z-i)}}return x(t,e,r,n,0),(h||f)(d,p,s)}class Nt{constructor(){this.map=new WeakMap}setBuffer(t,e,r){let n=this.map.get(t);n||this.map.set(t,n=new Map),n.set(e,r)}getBuffer(t,e){let r=this.map.get(t);return r&&r.get(e)}set(t,e){t instanceof R?this.setBuffer(t.context.buffer,t.index,e):t instanceof B&&this.map.set(t.tree,e)}get(t){return t instanceof R?this.getBuffer(t.context.buffer,t.index):t instanceof B?this.map.get(t.tree):void 0}cursorSet(t,e){t.buffer?this.setBuffer(t.buffer.buffer,t.index,e):this.map.set(t.tree,e)}cursorGet(t){return t.buffer?this.getBuffer(t.buffer.buffer,t.index):this.map.get(t.tree)}}class Q{constructor(t,e,r,n,i=!1,s=!1){this.from=t,this.to=e,this.tree=r,this.offset=n,this.open=(i?1:0)|(s?2:0)}get openStart(){return(this.open&1)>0}get openEnd(){return(this.open&2)>0}static addTree(t,e=[],r=!1){let n=[new Q(0,t.length,t,0,!1,r)];for(let i of e)i.to>t.length&&n.push(i);return n}static applyChanges(t,e,r=128){if(!e.length)return t;let n=[],i=1,s=t.length?t[0]:null;for(let h=0,f=0,a=0;;h++){let l=h<e.length?e[h]:null,d=l?l.fromA:1e9;if(d-f>=r)for(;s&&s.from<d;){let p=s;if(f>=p.from||d<=p.to||a){let x=Math.max(p.from,f)-a,_=Math.min(p.to,d)-a;p=x>=_?null:new Q(x,_,p.tree,p.offset+a,h>0,!!l)}if(p&&n.push(p),s.to>d)break;s=i<t.length?t[i++]:null}if(!l)break;f=l.toA,a=l.toA-l.toB}return n}}class Bt{startParse(t,e,r){return typeof t=="string"&&(t=new Tt(t)),r=r?r.length?r.map(n=>new P(n.from,n.to)):[new P(0,0)]:[new P(0,t.length)],this.createParse(t,e||[],r)}parse(t,e,r){let n=this.startParse(t,e,r);for(;;){let i=n.advance();if(i)return i}}}class Tt{constructor(t){this.string=t}get length(){return this.string.length}chunk(t){return this.string.slice(t)}get lineChunks(){return!1}read(t,e){return this.string.slice(t,e)}}function Mt(o){return(t,e,r,n)=>new Et(t,o,e,r,n)}class gt{constructor(t,e,r,n,i){this.parser=t,this.parse=e,this.overlay=r,this.target=n,this.from=i}}function mt(o){if(!o.length||o.some(t=>t.from>=t.to))throw new RangeError("Invalid inner parse ranges given: "+JSON.stringify(o))}class zt{constructor(t,e,r,n,i,s,h){this.parser=t,this.predicate=e,this.mounts=r,this.index=n,this.start=i,this.target=s,this.prev=h,this.depth=0,this.ranges=[]}}const it=new v({perNode:!0});class Et{constructor(t,e,r,n,i){this.nest=e,this.input=r,this.fragments=n,this.ranges=i,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=t}advance(){if(this.baseParse){let r=this.baseParse.advance();if(!r)return null;if(this.baseParse=null,this.baseTree=r,this.startInner(),this.stoppedAt!=null)for(let n of this.inner)n.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length){let r=this.baseTree;return this.stoppedAt!=null&&(r=new M(r.type,r.children,r.positions,r.length,r.propValues.concat([[it,this.stoppedAt]]))),r}let t=this.inner[this.innerDone],e=t.parse.advance();if(e){this.innerDone++;let r=Object.assign(Object.create(null),t.target.props);r[v.mounted.id]=new q(e,t.overlay,t.parser),t.target.props=r}return null}get parsedPos(){if(this.baseParse)return 0;let t=this.input.length;for(let e=this.innerDone;e<this.inner.length;e++)this.inner[e].from<t&&(t=Math.min(t,this.inner[e].parse.parsedPos));return t}stopAt(t){if(this.stoppedAt=t,this.baseParse)this.baseParse.stopAt(t);else for(let e=this.innerDone;e<this.inner.length;e++)this.inner[e].parse.stopAt(t)}startInner(){let t=new Ft(this.fragments),e=null,r=null,n=new Y(new B(this.baseTree,this.ranges[0].from,0,null),k.IncludeAnonymous|k.IgnoreMounts);t:for(let i,s;;){let h=!0,f;if(this.stoppedAt!=null&&n.from>=this.stoppedAt)h=!1;else if(t.hasNode(n)){if(e){let a=e.mounts.find(l=>l.frag.from<=n.from&&l.frag.to>=n.to&&l.mount.overlay);if(a)for(let l of a.mount.overlay){let d=l.from+a.pos,p=l.to+a.pos;d>=n.from&&p<=n.to&&!e.ranges.some(x=>x.from<p&&x.to>d)&&e.ranges.push({from:d,to:p})}}h=!1}else if(r&&(s=Pt(r.ranges,n.from,n.to)))h=s!=2;else if(!n.type.isAnonymous&&(i=this.nest(n,this.input))&&(n.from<n.to||!i.overlay)){n.tree||Ot(n);let a=t.findMounts(n.from,i.parser);if(typeof i.overlay=="function")e=new zt(i.parser,i.overlay,a,this.inner.length,n.from,n.tree,e);else{let l=bt(this.ranges,i.overlay||(n.from<n.to?[new P(n.from,n.to)]:[]));l.length&&mt(l),(l.length||!i.overlay)&&this.inner.push(new gt(i.parser,l.length?i.parser.startParse(this.input,wt(a,l),l):i.parser.startParse(""),i.overlay?i.overlay.map(d=>new P(d.from-n.from,d.to-n.from)):null,n.tree,l.length?l[0].from:n.from)),i.overlay?l.length&&(r={ranges:l,depth:0,prev:r}):h=!1}}else e&&(f=e.predicate(n))&&(f===!0&&(f=new P(n.from,n.to)),f.from<f.to&&e.ranges.push(f));if(h&&n.firstChild())e&&e.depth++,r&&r.depth++;else for(;!n.nextSibling();){if(!n.parent())break t;if(e&&!--e.depth){let a=bt(this.ranges,e.ranges);a.length&&(mt(a),this.inner.splice(e.index,0,new gt(e.parser,e.parser.startParse(this.input,wt(e.mounts,a),a),e.ranges.map(l=>new P(l.from-e.start,l.to-e.start)),e.target,a[0].from))),e=e.prev}r&&!--r.depth&&(r=r.prev)}}}}function Pt(o,t,e){for(let r of o){if(r.from>=e)break;if(r.to>t)return r.from<=t&&r.to>=e?2:1}return 0}function yt(o,t,e,r,n,i){if(t<e){let s=o.buffer[t+1];r.push(o.slice(t,e,s)),n.push(s-i)}}function Ot(o){let{node:t}=o,e=[],r=t.context.buffer;do e.push(o.index),o.parent();while(!o.tree);let n=o.tree,i=n.children.indexOf(r),s=n.children[i],h=s.buffer,f=[i];function a(l,d,p,x,_,N){let F=e[N],j=[],z=[];yt(s,l,F,j,z,x);let I=h[F+1],L=h[F+2];f.push(j.length);let y=N?a(F+4,h[F+3],s.set.types[h[F]],I,L-I,N-1):t.toTree();return j.push(y),z.push(I-x),yt(s,h[F+3],d,j,z,x),new M(p,j,z,_)}n.children[i]=a(0,h.length,O.none,0,s.length,e.length-1);for(let l of f){let d=o.tree.children[l],p=o.tree.positions[l];o.yield(new B(d,p+o.from,l,o._tree))}}class xt{constructor(t,e){this.offset=e,this.done=!1,this.cursor=t.cursor(k.IncludeAnonymous|k.IgnoreMounts)}moveTo(t){let{cursor:e}=this,r=t-this.offset;for(;!this.done&&e.from<r;)e.to>=t&&e.enter(r,1,k.IgnoreOverlays|k.ExcludeBuffers)||e.next(!1)||(this.done=!0)}hasNode(t){if(this.moveTo(t.from),!this.done&&this.cursor.from+this.offset==t.from&&this.cursor.tree)for(let e=this.cursor.tree;;){if(e==t.tree)return!0;if(e.children.length&&e.positions[0]==0&&e.children[0]instanceof M)e=e.children[0];else break}return!1}}class Ft{constructor(t){var e;if(this.fragments=t,this.curTo=0,this.fragI=0,t.length){let r=this.curFrag=t[0];this.curTo=(e=r.tree.prop(it))!==null&&e!==void 0?e:r.to,this.inner=new xt(r.tree,-r.offset)}else this.curFrag=this.inner=null}hasNode(t){for(;this.curFrag&&t.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=t.from&&this.curTo>=t.to&&this.inner.hasNode(t)}nextFrag(){var t;if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let e=this.curFrag=this.fragments[this.fragI];this.curTo=(t=e.tree.prop(it))!==null&&t!==void 0?t:e.to,this.inner=new xt(e.tree,-e.offset)}}findMounts(t,e){var r;let n=[];if(this.inner){this.inner.cursor.moveTo(t,1);for(let i=this.inner.cursor.node;i;i=i.parent){let s=(r=i.tree)===null||r===void 0?void 0:r.prop(v.mounted);if(s&&s.parser==e)for(let h=this.fragI;h<this.fragments.length;h++){let f=this.fragments[h];if(f.from>=i.to)break;f.tree==this.curFrag.tree&&n.push({frag:f,pos:i.from-f.offset,mount:s})}}}return n}}function bt(o,t){let e=null,r=t;for(let n=1,i=0;n<o.length;n++){let s=o[n-1].to,h=o[n].from;for(;i<r.length;i++){let f=r[i];if(f.from>=h)break;f.to<=s||(e||(r=e=t.slice()),f.from<s?(e[i]=new P(f.from,s),f.to>h&&e.splice(i+1,0,new P(h,f.to))):f.to>h?e[i--]=new P(h,f.to):e.splice(i--,1))}}return r}function jt(o,t,e,r){let n=0,i=0,s=!1,h=!1,f=-1e9,a=[];for(;;){let l=n==o.length?1e9:s?o[n].to:o[n].from,d=i==t.length?1e9:h?t[i].to:t[i].from;if(s!=h){let p=Math.max(f,e),x=Math.min(l,d,r);p<x&&a.push(new P(p,x))}if(f=Math.min(l,d),f==1e9)break;l==f&&(s?(s=!1,n++):s=!0),d==f&&(h?(h=!1,i++):h=!0)}return a}function wt(o,t){let e=[];for(let{pos:r,mount:n,frag:i}of o){let s=r+(n.overlay?n.overlay[0].from:0),h=s+n.tree.length,f=Math.max(i.from,s),a=Math.min(i.to,h);if(n.overlay){let l=n.overlay.map(p=>new P(p.from+r,p.to+r)),d=jt(t,l,f,a);for(let p=0,x=f;;p++){let _=p==d.length,N=_?a:d[p].from;if(N>x&&e.push(new Q(x,N,n.tree,-s,i.from>=x||i.openStart,i.to<=N||i.openEnd)),_)break;x=d[p].to}}else e.push(new Q(f,a,n.tree,-s,i.from>=s||i.openStart,i.to<=h||i.openEnd))}return e}export{vt as DefaultBufferLength,k as IterMode,q as MountedTree,v as NodeProp,st as NodeSet,O as NodeType,Nt as NodeWeakMap,Bt as Parser,M as Tree,U as TreeBuffer,Y as TreeCursor,Q as TreeFragment,Mt as parseMixed};
